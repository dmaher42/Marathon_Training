<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Adaptive Marathon Plan</title>
  <style>
    :root {
      --bg-page: #f3f7fb;
      --bg-panel: #ffffff;
      --bg-muted: #f0f4ff;
      --text-strong: #0f172a;
      --text-muted: #475569;
      --line: #d7e3f5;
      --accent: #5f8df5;
      --accent-2: #8ab4ff;
      --done: #10b981;
      --missed: #ef4444;
      --planned: #334155;
      --shadow-lg: 0 18px 36px rgba(15, 23, 42, 0.12);
      --shadow-sm: 0 10px 20px rgba(15, 23, 42, 0.08);
      --radius-lg: 18px;
      --radius-md: 14px;
      --radius-sm: 10px;
      --space-1: 6px;
      --space-2: 10px;
      --space-3: 14px;
      --space-4: 18px;
      --space-5: 22px;
      --text-sm: 12px;
      --text-md: 14px;
      --text-lg: 16px;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg-page);
      color: var(--text-strong);
      line-height: 1.5;
    }

    h1 { margin: 0; font-size: var(--text-lg); letter-spacing: 0.2px; }
    .muted { color: var(--text-muted); }

    header {
      position: sticky;
      top: 0;
      z-index: 50;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--line);
    }

    .topbar {
      max-width: 1180px;
      margin: 0 auto;
      padding: var(--space-3) var(--space-3);
      display: flex;
      align-items: center;
      gap: var(--space-3);
      justify-content: space-between;
      flex-wrap: wrap;
    }

    .brand { display: flex; align-items: center; gap: var(--space-2); }
    .logo {
      width: 44px;
      height: 44px;
      border-radius: 14px;
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      color: #fff;
      display: grid;
      place-items: center;
      font-weight: 900;
      box-shadow: var(--shadow-sm);
      flex: 0 0 auto;
    }
    .sub { margin-top: 2px; font-size: var(--text-sm); color: var(--text-muted); }

    .controls { display: flex; gap: var(--space-2); flex-wrap: wrap; align-items: center; }
    button, select {
      border: 1px solid var(--line);
      background: #fff;
      border-radius: var(--radius-md);
      padding: 10px 12px;
      font-weight: 800;
      color: var(--text-strong);
      box-shadow: var(--shadow-sm);
      cursor: pointer;
    }
    button:hover { filter: brightness(1.02); }
    button:active { transform: translateY(1px); }
    select { cursor: pointer; }

    main { max-width: 1180px; margin: 0 auto; padding: var(--space-3) var(--space-3) 100px; }

    .card {
      margin-top: var(--space-3);
      padding: var(--space-3);
      border: 1px solid var(--line);
      border-radius: var(--radius-lg);
      background: var(--bg-panel);
      box-shadow: var(--shadow-lg);
      display: flex;
      flex-direction: column;
      gap: var(--space-3);
    }

    .card details {
      margin: calc(var(--space-2) * -1);
      padding: calc(var(--space-2) * 1);
      border-radius: inherit;
    }

    .card summary {
      list-style: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-2);
      padding: var(--space-2);
      border-radius: var(--radius-md);
      border: 1px solid var(--line);
      background: var(--bg-muted);
      box-shadow: var(--shadow-sm);
    }

    .card summary::-webkit-details-marker {
      display: none;
    }

    .card summary:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 4px;
    }

    .card .summary-text { display: flex; flex-direction: column; gap: 4px; }
    .card .summary-title { margin: 0; font-size: var(--text-lg); }
    .card .summary-subtitle { color: var(--text-muted); }

    .card .summary-chevron {
      transition: transform 0.15s ease;
      flex-shrink: 0;
    }

    .card details[open] .summary-chevron { transform: rotate(180deg); }

    .form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(230px, 1fr));
      gap: var(--space-3);
      align-items: end;
    }

    .form-group { display: flex; flex-direction: column; gap: 6px; }
    .form-group label { font-weight: 800; font-size: var(--text-md); }
    .form-group small { color: var(--text-muted); font-size: var(--text-sm); }
    .form-group input[type="text"],
    .form-group input[type="date"],
    .form-group input[type="number"],
    .form-group select {
      padding: 10px 12px;
      border-radius: var(--radius-md);
      border: 1px solid var(--line);
      font-size: var(--text-md);
      background: #fff;
      box-shadow: var(--shadow-sm);
    }
    .form-group input[type="checkbox"] { transform: scale(1.1); }

    .xtrain-row { display: grid; grid-template-columns: auto 1fr; gap: var(--space-2); align-items: center; }
    .xtrain-row .minutes { display: flex; align-items: center; gap: 6px; }
    .xtrain-row input[type="number"] { width: 90px; }
    .xtrain-row label { font-weight: 700; display: flex; align-items: center; gap: 8px; }

    .form-actions { display: flex; justify-content: flex-start; }
    .form-actions button { padding-inline: 18px; }

    .pace-guide {
      margin-top: var(--space-2);
      padding: var(--space-2) var(--space-3) var(--space-3);
      border: 1px solid var(--line);
      border-radius: var(--radius-lg);
      background: linear-gradient(180deg, rgba(234, 242, 255, 0.8), #fff);
      box-shadow: var(--shadow-sm);
      display: flex;
      flex-direction: column;
      gap: var(--space-2);
      color: var(--text-muted);
      font-size: var(--text-sm);
    }
    .pace-guide .title { font-weight: 900; color: var(--text-strong); letter-spacing: 0.2px; display: flex; align-items: center; gap: var(--space-2); }
    .pace-guide .note { color: var(--text-muted); font-size: var(--text-sm); }
    .pace-toggle {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-2);
      padding: var(--space-2);
      border-radius: var(--radius-md);
      border: 1px dashed rgba(95, 141, 245, 0.35);
      background: #fff;
      cursor: pointer;
    }
    .pace-toggle .label { display: flex; flex-direction: column; gap: 2px; text-align: left; }
    .pace-toggle .label b { font-size: var(--text-md); }
    .pace-toggle .label span { color: var(--text-muted); font-size: var(--text-sm); }
    .pace-toggle .chevron { transition: transform 0.15s ease; }
    .pace-toggle[data-open="true"] .chevron { transform: rotate(180deg); }
    .settings-toggle {
      border: 1px solid var(--line);
      background: #fff;
      border-radius: var(--radius-md);
      padding: 10px 12px;
      font-weight: 800;
      color: var(--text-strong);
      box-shadow: var(--shadow-sm);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-2);
    }
    .settings-toggle span { font-size: var(--text-sm); color: var(--text-muted); font-weight: 500; }
    .pace-settings { display: grid; grid-template-columns: repeat(auto-fit, minmax(230px, 1fr)); gap: var(--space-3); }
    .range-row { display: flex; align-items: center; gap: var(--space-2); }
    .range-row input[type="range"] { flex: 1; }
    .unit-toggle { display: inline-flex; border: 1px solid var(--line); border-radius: var(--radius-md); overflow: hidden; box-shadow: var(--shadow-sm); }
    .unit-toggle button { border: none; box-shadow: none; padding: 10px 12px; font-weight: 800; background: #fff; }
    .unit-toggle button[data-active="true"] { background: rgba(95, 141, 245, 0.12); border-right: 1px solid var(--line); }
    .unit-toggle button:first-child { border-right: 1px solid var(--line); }
    .hr-note { font-size: var(--text-sm); color: var(--text-muted); }

    .week-meta {
      margin-top: var(--space-3);
      padding: var(--space-3);
      border: 1px solid var(--line);
      border-radius: var(--radius-lg);
      background: var(--bg-panel);
      box-shadow: var(--shadow-lg);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-3);
      flex-wrap: wrap;
    }
    .week-title { font-size: var(--text-lg); font-weight: 900; display: flex; align-items: center; gap: var(--space-2); flex-wrap: wrap; }
    .week-phase, .week-totals { font-size: var(--text-sm); color: var(--text-muted); }
    .view-toggle { display: flex; gap: var(--space-2); flex-wrap: wrap; }
    .view-toggle button { box-shadow: none; padding: 8px 12px; }
    .view-toggle button[data-active="true"] { background: rgba(95, 141, 245, 0.12); border-color: rgba(95, 141, 245, 0.45); }

    .status-pill { padding: 4px 10px; border-radius: 999px; border: 1px solid var(--line); font-size: var(--text-sm); display: inline-flex; align-items: center; gap: 8px; }
    .status-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
    .status-green { background: #34d399; border: 1px solid #059669; }
    .status-yellow { background: #fbbf24; border: 1px solid #d97706; }
    .status-red { background: #fca5a5; border: 1px solid #ef4444; }
    .status-gray { background: #e2e8f0; border: 1px solid #cbd5e1; }

    .mobile-view-toggle { display: none; gap: var(--space-2); align-items: center; flex-wrap: wrap; }
    .mobile-view-toggle button { box-shadow: none; padding: 6px 10px; font-weight: 700; }
    .mobile-view-toggle button[data-active="true"] { background: rgba(95, 141, 245, 0.12); border-color: rgba(95, 141, 245, 0.45); }

    .week-grid { margin-top: var(--space-3); display: flex; flex-direction: column; gap: var(--space-3); }

    .week-summary { margin-top: var(--space-2); border: 1px solid var(--line); border-radius: var(--radius-lg); background: #fff; box-shadow: var(--shadow-sm); overflow: hidden; }
    .week-summary-header, .week-summary-totals { padding: var(--space-2) var(--space-3); background: var(--bg-muted); font-weight: 800; display: flex; justify-content: space-between; align-items: center; gap: var(--space-2); }
    .week-summary-list { display: flex; flex-direction: column; }
    .week-summary-row { display: grid; grid-template-columns: 1.1fr 1fr 0.9fr auto; gap: var(--space-2); padding: var(--space-2) var(--space-3); border-top: 1px solid var(--line); align-items: center; cursor: pointer; }
    .week-summary-row:hover { background: rgba(95, 141, 245, 0.06); }
    .week-summary-row .day { font-weight: 800; display: flex; align-items: center; gap: 8px; }
    .week-summary-row .label { color: var(--text-muted); font-size: var(--text-sm); }
    .week-summary-row .minutes { font-weight: 700; }
    .week-summary-row .status-chip { padding: 4px 8px; border-radius: 999px; border: 1px solid var(--line); font-size: var(--text-sm); text-transform: capitalize; }
    .summary-long { color: var(--accent); font-weight: 900; }
    @media (max-width: 740px) { .mobile-view-toggle { display: flex; } .week-summary-row { grid-template-columns: 1fr 0.9fr auto; } .week-summary-row .label { display: none; } }

    .day-card {
      display: flex;
      flex-direction: row;
      width: 100%;
      border: 1px solid var(--line);
      border-radius: var(--radius-lg);
      overflow: hidden;
      background: #fff;
      box-shadow: var(--shadow-sm);
      min-height: 140px;
    }
    @media (max-width: 900px) {
      .day-card { flex-direction: column; }
    }

    .day-rail {
      flex: 0 0 210px;
      background: linear-gradient(180deg, rgba(226, 238, 255, 0.9), #fff);
      border-right: 1px solid var(--line);
      padding: var(--space-3);
      display: flex;
      flex-direction: column;
      gap: var(--space-2);
    }
    @media (max-width: 900px) { .day-rail { flex: initial; border-right: none; border-bottom: 1px solid var(--line); } }
    .day-name { font-weight: 900; font-size: var(--text-md); letter-spacing: 0.2px; }
    .long-chip { padding: 4px 8px; border-radius: 999px; background: rgba(95, 141, 245, 0.12); border: 1px solid var(--line); font-size: var(--text-sm); color: var(--text-strong); width: fit-content; }
    .day-meta { font-size: var(--text-sm); color: var(--text-muted); }

    .day-body { flex: 1; display: flex; gap: var(--space-3); padding: var(--space-3); background: linear-gradient(90deg, rgba(238, 246, 255, 0.55), #fff); }
    @media (max-width: 1050px) { .day-body { flex-direction: column; } }

    .col { display: flex; flex-direction: column; gap: var(--space-2); min-width: 0; }
    .col.primary { flex: 1 1 55%; }
    .col.recovery { flex: 1 1 45%; }

    .section-label { font-size: var(--text-sm); text-transform: uppercase; letter-spacing: 0.6px; color: var(--text-muted); display: flex; justify-content: space-between; align-items: center; gap: var(--space-2); }

    .session {
      border: 1px solid var(--line);
      background: var(--bg-muted);
      border-radius: var(--radius-md);
      overflow: hidden;
      transition: border-color 0.15s ease, box-shadow 0.15s ease;
    }
    .session[data-selected="true"] { box-shadow: 0 0 0 3px rgba(95, 141, 245, 0.3); border-color: rgba(95, 141, 245, 0.5); }
    .session[data-status="done"] { border-color: rgba(16, 185, 129, 0.3); box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.18); }
    .session[data-status="missed"] { border-color: rgba(239, 68, 68, 0.25); box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.16); }

    .session-head { display: flex; gap: var(--space-2); align-items: flex-start; justify-content: space-between; padding: var(--space-2); cursor: pointer; }
    .session-title { font-weight: 900; font-size: var(--text-md); line-height: 1.2; }
    .session-sub { font-size: var(--text-sm); color: var(--text-muted); }
    .chip { padding: 5px 8px; border-radius: 999px; border: 1px solid var(--line); background: #fff; font-size: var(--text-sm); color: var(--text-muted); white-space: nowrap; }
    .details { display: none; padding: 0 var(--space-2) var(--space-2); font-size: var(--text-sm); color: var(--text-muted); }
    .session[data-open="true"] .details { display: block; }

    .recovery-group { border: 1px dashed rgba(95, 141, 245, 0.35); background: rgba(234, 242, 255, 0.5); border-radius: var(--radius-md); padding: var(--space-2); }
    .recovery-header { display: flex; justify-content: space-between; align-items: center; gap: var(--space-2); cursor: pointer; font-weight: 900; font-size: var(--text-sm); }
    .recovery-count { padding: 4px 8px; border-radius: 999px; border: 1px solid var(--line); background: #fff; font-size: var(--text-sm); color: var(--text-muted); }
    .recovery-body { display: none; flex-direction: column; gap: var(--space-2); margin-top: var(--space-2); }
    .recovery-group[data-open="true"] .recovery-body { display: flex; }

    .action-bar {
      position: fixed;
      left: 0; right: 0; bottom: 0;
      background: rgba(255, 255, 255, 0.94);
      border-top: 1px solid var(--line);
      backdrop-filter: blur(10px);
      z-index: 70;
    }
    .action-inner { max-width: 1180px; margin: 0 auto; padding: var(--space-2) var(--space-3); display: flex; justify-content: space-between; align-items: center; gap: var(--space-3); flex-wrap: wrap; }
    .sel-info { display: flex; flex-direction: column; gap: 2px; min-width: 200px; }
    .sel-info b { font-size: var(--text-md); }
    .sel-info span { font-size: var(--text-sm); color: var(--text-muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 520px; }
    .btn-row { display: flex; gap: var(--space-2); flex-wrap: wrap; }
    .btn-row button { box-shadow: none; }
    .btn-row .done { border-color: rgba(16, 185, 129, 0.45); }
    .btn-row .miss { border-color: rgba(239, 68, 68, 0.35); }

    .toast {
      position: fixed;
      left: 50%; bottom: 70px;
      transform: translateX(-50%);
      background: #fff;
      border: 1px solid var(--line);
      border-radius: var(--radius-md);
      padding: var(--space-2) var(--space-3);
      box-shadow: var(--shadow-lg);
      font-size: var(--text-sm);
      display: none;
      z-index: 99;
    }
    .toast.show { display: block; }

    html[data-theme="purple-pastel"] {
      --bg-page: #fdfbff;
      --bg-panel: #ffffff;
      --bg-muted: #f3f0ff;
      --text-strong: #1e1b4b;
      --text-muted: #64748b;
      --line: #e9d5ff;
      --accent: #8b5cf6;
      --accent-2: #a78bfa;
    }
  </style>
  <script>
    try {
      const settings = JSON.parse(localStorage.getItem("marathonPlan_personalization_v1"));
      if (settings && settings.theme) {
        document.documentElement.setAttribute("data-theme", settings.theme);
      }
    } catch (e) {}
  </script>
</head>
<body>
<header>
  <div class="topbar">
    <div class="brand">
      <div class="logo">MP</div>
      <div>
        <h1>Adaptive Marathon Plan</h1>
        <div class="sub" id="subtitle">17 weeks • Goal 3:30 • Long run Saturday • Mark sessions Done/Missed to adapt</div>
      </div>
    </div>
    <div class="controls">
      <button id="prevWeek" aria-label="Previous week">◀ Week</button>
      <select id="weekSelect" aria-label="Select week"></select>
      <button id="nextWeek" aria-label="Next week">Week ▶</button>
      <button id="reset" title="Reset progress">Reset</button>
      <button id="tests" title="Run self-tests">Tests</button>
    </div>
  </div>
</header>

<main>
  <div class="card" id="personalizationCard" aria-label="Personalize plan">
    <details id="personalizationToggle" open>
      <summary aria-controls="personalizationForm">
        <div class="summary-text">
          <h2 class="summary-title">Personalize your marathon plan</h2>
          <div class="summary-subtitle">Set your race date, pacing, and cross-training preferences to tailor the 17-week template.</div>
        </div>
        <span class="summary-chevron" aria-hidden="true">▼</span>
      </summary>
      <form class="form-grid" id="personalizationForm">
      <div class="form-group">
        <label for="raceDate">Race date</label>
        <input type="date" id="raceDate" aria-label="Race date" title="Pick your target marathon date" />
        <small>Leave blank to keep the original 17-week schedule.</small>
      </div>
      <div class="form-group">
        <label for="planLength">Plan length (weeks)</label>
        <input type="number" id="planLength" min="1" inputmode="numeric" aria-label="Plan length in weeks" placeholder="Auto from race date" title="Set exact weeks or leave empty to auto-calc from race date" />
        <small>Defaults to 17 weeks if left blank.</small>
      </div>
      <div class="form-group">
        <label for="goalTime">Goal marathon time (hh:mm:ss)</label>
        <input type="text" id="goalTime" aria-label="Goal marathon time" placeholder="3:30:00" pattern="\d{1,2}:\d{2}(:\d{2})?" title="Enter in hh:mm or hh:mm:ss" />
        <small>Used to compute marathon pace.</small>
      </div>
      <div class="form-group">
        <label for="recentTime">Recent race time (hh:mm:ss)</label>
        <input type="text" id="recentTime" aria-label="Recent race time" placeholder="1:40:00" pattern="\d{1,2}:\d{2}(:\d{2})?" title="Recent half-marathon (or similar) time" />
        <small>Sets tempo and interval pacing.</small>
      </div>
      <div class="form-group">
        <label for="longRunDay">Long run day</label>
        <select id="longRunDay" aria-label="Select long run day" title="Choose which weekday to schedule the long run">
          <option value="0">Monday</option>
          <option value="1">Tuesday</option>
          <option value="2">Wednesday</option>
          <option value="3">Thursday</option>
          <option value="4">Friday</option>
          <option value="5">Saturday</option>
          <option value="6">Sunday</option>
        </select>
      </div>
      <div class="form-group">
        <label>Cross-training preferences</label>
        <div class="xtrain-row">
          <label for="bikeEnabled"><input type="checkbox" id="bikeEnabled" aria-label="Enable bike" /> Bike</label>
          <div class="minutes"><input type="number" id="bikeMinutes" min="0" step="5" aria-label="Bike minutes per week" /> <small>min / week</small></div>
        </div>
        <div class="xtrain-row">
          <label for="swimEnabled"><input type="checkbox" id="swimEnabled" aria-label="Enable swim" /> Swim</label>
          <div class="minutes"><input type="number" id="swimMinutes" min="0" step="5" aria-label="Swim minutes per week" /> <small>min / week</small></div>
        </div>
        <div class="xtrain-row">
          <label for="strengthEnabled"><input type="checkbox" id="strengthEnabled" aria-label="Enable strength" /> Strength</label>
          <div class="minutes"><input type="number" id="strengthMinutes" min="0" step="5" aria-label="Strength minutes per week" /> <small>min / week</small></div>
        </div>
      </div>
      <details id="paceSettings" open>
        <summary class="settings-toggle">Pace settings <span>(zones, adjustment, units)</span></summary>
        <div class="pace-settings">
          <div class="form-group">
            <label for="paceSource">Pace source</label>
            <select id="paceSource" aria-label="Select pace source">
              <option value="goal">Goal marathon time</option>
              <option value="recent">Recent race</option>
              <option value="trial">Custom time trial</option>
            </select>
            <small>Pick which effort to base your zones on.</small>
          </div>
          <div class="form-group" id="trialDistanceWrap">
            <label for="trialDistance">Trial distance</label>
            <select id="trialDistance" aria-label="Select time trial distance">
              <option value="5">5K</option>
              <option value="10">10K</option>
              <option value="21.0975">Half marathon</option>
              <option value="42.195">Marathon</option>
            </select>
            <small>Used only when "Custom time trial" is selected.</small>
          </div>
          <div class="form-group" id="trialTimeWrap">
            <label for="trialTime">Trial time (hh:mm:ss)</label>
            <input type="text" id="trialTime" aria-label="Custom time trial result" placeholder="0:25:00" pattern="\d{1,2}:\d{2}(:\d{2})?" />
            <small>Enter your best recent effort.</small>
          </div>
          <div class="form-group">
            <label for="adjustment">Heat / effort adjustment</label>
            <div class="range-row">
              <input type="range" id="adjustment" min="-20" max="30" step="1" aria-label="Adjust paces slower or faster" />
              <div id="adjustmentValue" aria-live="polite">0 sec/km</div>
            </div>
            <small>Positive = slower paces (hot/hilly/tired). Negative = faster (cool/flat/strong).</small>
          </div>
          <div class="form-group">
            <label for="themeSelect">Theme</label>
            <select id="themeSelect" aria-label="Select theme">
              <option value="default">Default</option>
              <option value="purple-pastel">Pastel Purple</option>
            </select>
            <small>Choose your color palette.</small>
          </div>
          <div class="form-group">
            <label>Units</label>
            <div class="unit-toggle" role="group" aria-label="Toggle units">
              <button type="button" id="unitKm" data-unit="km" data-active="true">km</button>
              <button type="button" id="unitMi" data-unit="mi" data-active="false">mi</button>
            </div>
            <small>Switch pace display between km and miles.</small>
          </div>
          <div class="form-group">
            <label for="maxHr">Heart rate guidance (optional)</label>
            <input type="number" id="maxHr" min="0" inputmode="numeric" aria-label="Max heart rate" placeholder="Max HR" />
            <small>Set max HR and easy cap for context; use HR cap on easy days.</small>
          </div>
          <div class="form-group">
            <label for="easyHr">Easy HR cap</label>
            <input type="number" id="easyHr" min="0" inputmode="numeric" aria-label="Easy heart rate cap" placeholder="Easy HR cap" />
            <small class="hr-note">Use HR cap for easy/long days; paces shown are guidance.</small>
          </div>
        </div>
      </details>
      <div class="form-actions">
        <button type="submit" id="generatePlan">Generate Plan</button>
      </div>
    </form>
    </details>
  </div>

  <div class="pace-guide" id="paceGuide" aria-label="Pace guide"></div>

  <div class="week-meta" id="weekMeta">
    <div>
      <div class="week-title" id="weekTitle"><span id="weekLabel">Week</span> <span id="weekStatusPill" class="status-pill"><span class="status-dot status-gray"></span><span id="weekStatusText">Future</span></span></div>
      <div class="week-phase" id="weekPhase">Phase</div>
    </div>
    <div class="week-totals" id="weekTotals">Totals</div>
    <div class="mobile-view-toggle" id="mobileViewToggle" aria-label="Condensed view">
      <button type="button" id="btnSummary" data-active="false">Summary</button>
      <button type="button" id="btnWeekDetailed" data-active="true">Detailed</button>
    </div>
    <div class="view-toggle" aria-label="View mode">
      <button id="btnCompact" data-active="false" title="Hide details by default">Compact</button>
      <button id="btnDetailed" data-active="true" title="Show details by default">Detailed</button>
    </div>
  </div>

  <div class="week-grid" id="weekGrid" aria-live="polite"></div>
</main>

<div class="action-bar">
  <div class="action-inner">
    <div class="sel-info">
      <b id="selTitle">Select a session</b>
      <span id="selSub">Tap a session card to show actions</span>
    </div>
    <div class="btn-row">
      <button class="done" data-set="done">Done</button>
      <button class="miss" data-set="missed">Missed</button>
      <button data-set="planned">Planned</button>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
(() => {
  // =============================
  // Config + pace constants
  // =============================
  const DEFAULT_SETTINGS = {
    raceDate: "",
    planLength: "",
    goalTime: "3:30:00",
    recentTime: "1:40:00",
    longRunDay: "5",
    paceSource: "goal",
    trialDistance: "5",
    trialTime: "0:25:00",
    adjustment: 0,
    unit: "km",
    theme: "default",
    maxHr: "",
    easyHr: "",
    crossTraining: {
      bike: { enabled: true, minutes: 55 },
      swim: { enabled: true, minutes: 65 },
      strength: { enabled: true, minutes: 45 },
    },
  };
  const MARATHON_KM = 42.195;
  const HALF_KM = 21.0975;
  const XTRAIN_TEMPLATES = { bike: [30, 25], swim: [25, 20, 20], strength: [25, 20] };
  const STORAGE_KEY = "marathonPlan17w_weekview_v3";
  const SETTINGS_KEY = "marathonPlan_personalization_v1";
  const UI_STATE_KEY = "marathonPlan_ui_v1";
  const DAY_NAMES = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
  const LONG_DAY_NAMES = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];

  // Helpers
  function toSeconds(h, m, s = 0) { return h * 3600 + m * 60 + s; }
  function pacePerKmFromRace(seconds, km) { return seconds / km; }
  function parseTimeToSeconds(str) { return parseTimeInput(str); }
  function convertSecPerKmToUnit(secPerKm, unit) { return unit === "mi" ? secPerKm * 1.609344 : secPerKm; }
  function secondsToPaceString(secPerKm, unit = "km") {
    if (!Number.isFinite(secPerKm) || secPerKm <= 0) return "-";
    const secPerUnit = convertSecPerKmToUnit(secPerKm, unit);
    const mm = Math.floor(secPerUnit / 60);
    const ss = Math.round(secPerUnit % 60);
    return `${mm}:${String(ss).padStart(2, "0")}/${unit}`;
  }
  function fmtPace(secPerKm, unit = currentUnit) { return secondsToPaceString(secPerKm, unit); }
  function fmtRange(range, unit = currentUnit) { return `${fmtPace(range[0], unit)}–${fmtPace(range[1], unit)}`; }
  function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }
  function uid(prefix) { return `${prefix}_${Math.random().toString(36).slice(2, 9)}`; }
  function minToText(min) { const h = Math.floor(min / 60); const m = min % 60; return h ? `${h}h ${m}m` : `${m}m`; }
  function escapeHtml(str) { return String(str).replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;"); }

  // =============================
  // UI State (collapsed guides, view modes)
  // =============================
  const DEFAULT_UI_STATE = { detailed: true, paceCollapsed: true, summaryMobile: true };
  function isMobile() { return window.matchMedia("(max-width: 740px)").matches; }
  function loadUIState() {
    try {
      const raw = localStorage.getItem(UI_STATE_KEY);
      if (!raw) return { ...DEFAULT_UI_STATE };
      return { ...DEFAULT_UI_STATE, ...JSON.parse(raw) };
    } catch {
      return { ...DEFAULT_UI_STATE };
    }
  }
  function saveUIState(next) { try { localStorage.setItem(UI_STATE_KEY, JSON.stringify(next)); } catch {} }

  function parseTimeInput(value) {
    if (!value && value !== 0) return null;
    const parts = String(value).split(":").map((p) => p.trim());
    if (parts.length < 2 || parts.length > 3) return null;
    const nums = parts.map((p) => Number(p));
    if (nums.some((n) => Number.isNaN(n) || n < 0)) return null;
    const [h, m, s = 0] = parts.length === 2 ? [nums[0], nums[1], 0] : nums;
    if (m >= 60 || s >= 60) return null;
    return toSeconds(h, m, s);
  }
  function normalizeTimeString(value, fallback) {
    const sec = parseTimeInput(value);
    if (!Number.isFinite(sec)) return fallback;
    const h = Math.floor(sec / 3600);
    const m = Math.floor((sec % 3600) / 60);
    const s = Math.round(sec % 60);
    return `${h}:${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
  }

  function deriveWeeks(settings) {
    const planLength = Number(settings.planLength);
    if (Number.isFinite(planLength) && planLength > 0) return Math.round(planLength);
    if (settings.raceDate) {
      const race = new Date(settings.raceDate);
      if (!Number.isNaN(race.getTime())) {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const diffWeeks = Math.ceil((race.getTime() - today.getTime()) / (1000 * 60 * 60 * 24 * 7));
        if (diffWeeks > 0) return diffWeeks;
      }
    }
    return 17;
  }

  function normalizeCrossTraining(input, key) {
    const defaults = DEFAULT_SETTINGS.crossTraining[key];
    const enabled = input && typeof input.enabled === "boolean" ? input.enabled : defaults.enabled;
    const minutes = input && Number.isFinite(Number(input.minutes)) && Number(input.minutes) >= 0 ? Number(input.minutes) : defaults.minutes;
    return { enabled, minutes };
  }

  function normalizeSettings(input = {}) {
    const base = { ...DEFAULT_SETTINGS, ...input };
    const cross = {
      bike: normalizeCrossTraining(base.crossTraining?.bike || base.crossTraining?.Bike || base.crossTraining?.BIKE, "bike"),
      swim: normalizeCrossTraining(base.crossTraining?.swim || base.crossTraining?.Swim || base.crossTraining?.SWIM, "swim"),
      strength: normalizeCrossTraining(base.crossTraining?.strength || base.crossTraining?.Strength || base.crossTraining?.STRENGTH, "strength"),
    };
    const parsedLong = Number(base.longRunDay);
    const longRunDay = Number.isFinite(parsedLong) && parsedLong >= 0 ? String(parsedLong % 7) : DEFAULT_SETTINGS.longRunDay;
    const paceSource = ["goal", "recent", "trial"].includes(base.paceSource) ? base.paceSource : DEFAULT_SETTINGS.paceSource;
    const adjustment = Number.isFinite(Number(base.adjustment)) ? clamp(Number(base.adjustment), -20, 30) : DEFAULT_SETTINGS.adjustment;
    const unit = base.unit === "mi" ? "mi" : "km";
    const theme = base.theme === "purple-pastel" ? "purple-pastel" : "default";
    const trialDistance = String(base.trialDistance || DEFAULT_SETTINGS.trialDistance);
    const trialTime = normalizeTimeString(base.trialTime, DEFAULT_SETTINGS.trialTime);
    const maxHr = base.maxHr === null || base.maxHr === undefined ? "" : String(base.maxHr).trim();
    const easyHr = base.easyHr === null || base.easyHr === undefined ? "" : String(base.easyHr).trim();
    return {
      raceDate: base.raceDate || "",
      planLength: base.planLength === 0 ? "" : base.planLength === null ? "" : base.planLength === undefined ? "" : base.planLength,
      goalTime: normalizeTimeString(base.goalTime, DEFAULT_SETTINGS.goalTime),
      recentTime: normalizeTimeString(base.recentTime, DEFAULT_SETTINGS.recentTime),
      longRunDay,
      paceSource,
      trialDistance,
      trialTime,
      adjustment,
      unit,
      theme,
      maxHr,
      easyHr,
      crossTraining: cross,
    };
  }

  function buildConfigFromSettings(settings) {
    const goalSec = parseTimeInput(settings.goalTime) ?? parseTimeInput(DEFAULT_SETTINGS.goalTime);
    const recentSec = parseTimeInput(settings.recentTime) ?? parseTimeInput(DEFAULT_SETTINGS.recentTime);
    const weeks = deriveWeeks(settings);
    const goalHours = Math.floor(goalSec / 3600);
    const goalMinutes = Math.floor((goalSec % 3600) / 60);
    const recentHours = Math.floor(recentSec / 3600);
    const recentMinutes = Math.floor((recentSec % 3600) / 60);
    return {
      weeks,
      targetMarathon: { hours: goalHours, minutes: goalMinutes },
      recentHalfMarathon: { hours: recentHours, minutes: recentMinutes },
    };
  }

  function predictTimeForDistance(timeSeconds, fromKm, toKm) {
    if (!Number.isFinite(timeSeconds) || !Number.isFinite(fromKm) || fromKm <= 0) return null;
    return timeSeconds * Math.pow(toKm / fromKm, 1.06);
  }

  function computeBaseZones(goalSeconds, recentSeconds) {
    const hmPace = pacePerKmFromRace(recentSeconds, HALF_KM);
    const goalMp = pacePerKmFromRace(goalSeconds, MARATHON_KM);
    const intervals = [hmPace - 39, hmPace - 24];
    return {
      easy: [goalMp + 46, goalMp + 91],
      long: [goalMp + 31, goalMp + 71],
      mp: [goalMp - 4, goalMp + 6],
      tempo: [hmPace - 14, hmPace - 4],
      intervals,
      int: intervals,
    };
  }

  function computeZonesFromSource(sourceType, raceDistanceKm, timeSeconds, goalTimeSeconds, recentHalfSeconds) {
    const distance = Number(raceDistanceKm) || HALF_KM;
    const primaryTime = Number(timeSeconds);
    const goalSeconds = Number(goalTimeSeconds);
    const recentSeconds = Number(recentHalfSeconds);
    const predict = (target) => predictTimeForDistance(primaryTime, distance, target);
    const marathonSeconds = sourceType === "goal" && Number.isFinite(goalSeconds)
      ? goalSeconds
      : predict(MARATHON_KM) ?? goalSeconds ?? parseTimeInput(DEFAULT_SETTINGS.goalTime);
    const halfSeconds = (() => {
      if (sourceType === "goal" && Number.isFinite(recentSeconds)) return recentSeconds;
      const predicted = predict(HALF_KM);
      if (Number.isFinite(predicted)) return predicted;
      if (Number.isFinite(recentSeconds)) return recentSeconds;
      return predictTimeForDistance(marathonSeconds, MARATHON_KM, HALF_KM) ?? parseTimeInput(DEFAULT_SETTINGS.recentTime);
    })();
    return computeBaseZones(marathonSeconds, halfSeconds);
  }

  function applyAdjustment(zones, adjustmentSeconds = 0) {
    const adj = Number(adjustmentSeconds) || 0;
    const out = {};
    Object.entries(zones || {}).forEach(([k, range]) => {
      if (!Array.isArray(range)) return;
      out[k] = range.map((v) => v + adj);
    });
    return out;
  }

  function settingsSignature(settings, config) { return JSON.stringify({ settings, weeks: config.weeks }); }

  function loadPersonalizationSettings() {
    try {
      const raw = localStorage.getItem(SETTINGS_KEY);
      if (!raw) return DEFAULT_SETTINGS;
      const parsed = JSON.parse(raw);
      return { ...DEFAULT_SETTINGS, ...parsed, crossTraining: { ...DEFAULT_SETTINGS.crossTraining, ...(parsed.crossTraining || {}) } };
    } catch {
      return DEFAULT_SETTINGS;
    }
  }

  function savePersonalizationSettings(settings) {
    try { localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings)); } catch {}
  }

  function computeZonesFromSettings(settings) {
    const goalSeconds = parseTimeToSeconds(settings.goalTime) ?? parseTimeToSeconds(DEFAULT_SETTINGS.goalTime);
    const recentSeconds = parseTimeToSeconds(settings.recentTime) ?? parseTimeToSeconds(DEFAULT_SETTINGS.recentTime);
    const sourceType = settings.paceSource || "goal";
    let sourceDistance = settings.paceSource === "goal" ? MARATHON_KM : HALF_KM;
    let sourceTime = sourceType === "goal" ? goalSeconds : recentSeconds;
    if (sourceType === "trial") {
      sourceDistance = Number(settings.trialDistance) || HALF_KM;
      sourceTime = parseTimeInput(settings.trialTime) ?? recentSeconds;
    }
    if (sourceType === "recent") {
      sourceDistance = HALF_KM;
      sourceTime = recentSeconds;
    }
    return computeZonesFromSource(sourceType, sourceDistance, sourceTime, goalSeconds, recentSeconds);
  }

  let currentSettings = normalizeSettings(loadPersonalizationSettings());
  let CONFIG = buildConfigFromSettings(currentSettings);
  let BASE_ZONES = computeZonesFromSettings(currentSettings);
  let PACE = applyAdjustment(BASE_ZONES, currentSettings.adjustment);
  let currentUnit = currentSettings.unit;
  let currentSignature = settingsSignature(currentSettings, CONFIG);

  // =============================
  // Plan generation
  // =============================

  function getPlanStructure(weeks) {
    const taperWeeks = clamp(Math.round(weeks * 0.15), 2, 3);
    const peakWeeks = clamp(Math.round(weeks * 0.12), 2, 3);
    const remaining = weeks - taperWeeks - peakWeeks;

    // Baseline (17 weeks): Taper=3, Peak=2, Remaining=12. Base=6, Build=6.
    const remainingBaseline = 12; // 6 + 6

    const extra = remaining - remainingBaseline;
    const extraBase = Math.round(extra * 0.40);
    const extraBuild = extra - extraBase;

    const baseWeeks = 6 + extraBase;
    const buildWeeks = 6 + extraBuild;

    return { baseWeeks, buildWeeks, peakWeeks, taperWeeks };
  }

  function getPhaseStats(i, structure) {
    let phase = "";
    let weekInPhase = 0;
    let phaseLength = 0;

    if (i < structure.baseWeeks) {
      phase = "Base";
      weekInPhase = i;
      phaseLength = structure.baseWeeks;
    } else if (i < structure.baseWeeks + structure.buildWeeks) {
      phase = "Build";
      weekInPhase = i - structure.baseWeeks;
      phaseLength = structure.buildWeeks;
    } else if (i < structure.baseWeeks + structure.buildWeeks + structure.peakWeeks) {
      phase = "Peak";
      weekInPhase = i - (structure.baseWeeks + structure.buildWeeks);
      phaseLength = structure.peakWeeks;
    } else {
      phase = "Taper";
      weekInPhase = i - (structure.baseWeeks + structure.buildWeeks + structure.peakWeeks);
      phaseLength = structure.taperWeeks;
    }
    return { phase, weekInPhase, phaseLength };
  }

  function weekPhase(i, structure) {
    if (!structure) return "Base";
    return getPhaseStats(i, structure).phase;
  }

  function isKeyRun(session) { return session.sport === "run" && session.intensity === "key"; }

  function applyCrossTrainingPreferences(days, prefs) {
    const bySport = { bike: [], swim: [], strength: [] };
    for (const d of days) {
      for (const s of d.sessions) {
        if (bySport[s.sport]) bySport[s.sport].push({ day: d, session: s });
      }
    }

    const distribute = (sessions, totalMinutes, template = []) => {
      if (!sessions.length) return;
      const templateTotal = template.reduce((a, b) => a + b, 0);
      if (template.length === sessions.length && templateTotal === totalMinutes) {
        sessions.forEach((s, idx) => { s.minutes = template[idx]; });
        return;
      }
      const count = sessions.length;
      const base = count ? Math.floor(totalMinutes / count) : 0;
      let remainder = Math.max(0, Math.round(totalMinutes - base * count));
      sessions.forEach((s, idx) => {
        const extra = remainder > 0 ? 1 : 0;
        s.minutes = base + extra;
        remainder -= extra;
      });
    };

    ["bike", "swim", "strength"].forEach((sport) => {
      const pref = prefs[sport] || { enabled: true, minutes: 0 };
      const sessions = bySport[sport];
      if (!pref.enabled) {
        days.forEach((d) => { d.sessions = d.sessions.filter((s) => s.sport !== sport); });
      } else {
        distribute(sessions.map((s) => s.session), pref.minutes, XTRAIN_TEMPLATES[sport]);
      }
    });
  }

  function generateWeek(weekIndex, ctx = { pace: PACE, settings: currentSettings, config: CONFIG, structure: null }) {
    const pace = ctx.pace || PACE;
    const settings = ctx.settings || currentSettings;
    const config = ctx.config || CONFIG;
    const structure = ctx.structure || getPlanStructure(config.weeks);

    const longRunDayIndex = Number(settings.longRunDay);
    const recoveryRunDay = longRunDayIndex === 6 ? 5 : 6;

    const { phase, weekInPhase, phaseLength } = getPhaseStats(weekIndex, structure);

    // Volume interpolation
    const baseStart = 250;
    const baseEnd = 325; // approx 250 + 5*15
    const buildStart = 340;
    const buildEnd = 415; // approx 325 + 5*18
    const peakVol = 410;

    let runMin = 0;
    if (phase === "Base") {
      // Interpolate 250 -> 325
      const t = phaseLength > 1 ? weekInPhase / (phaseLength - 1) : 0;
      runMin = Math.round(baseStart + t * (baseEnd - baseStart));
    } else if (phase === "Build") {
      // Interpolate 340 -> 415
      const t = phaseLength > 1 ? weekInPhase / (phaseLength - 1) : 0;
      runMin = Math.round(buildStart + t * (buildEnd - buildStart));
    } else if (phase === "Peak") {
       // Peak volume usually holds or slight dip
       // Original: peak - (13 - weekIndex) * 10
       // Let's keep it around 400-410
       runMin = Math.round(peakVol - (phaseLength - 1 - weekInPhase) * 10);
    } else {
      // Taper
      // Original logic: peak * (0.75, 0.6, 0.45)
      // We can map weekInPhase 0..T-1 to these factors
      // If T=3: 0.75, 0.60, 0.45
      // If T=2: 0.75, 0.45? Or 0.6, 0.45?
      // Let's interpolate 0.75 -> 0.45
      const startFactor = 0.75;
      const endFactor = 0.45;
      const t = phaseLength > 1 ? weekInPhase / (phaseLength - 1) : 0;
      runMin = Math.round(peakVol * (startFactor + t * (endFactor - startFactor)));
    }

    const isRecovery = phase !== "Taper" && ((weekIndex + 1) % 4 === 0);
    if (isRecovery) runMin = Math.round(runMin * 0.75);

    const longMinByPhase = (() => {
      if (phase === "Base") {
         const t = phaseLength > 1 ? weekInPhase / (phaseLength - 1) : 1;
         return clamp(Math.round((90 + t * (140 - 90)) / 5) * 5, 90, 140);
      }
      if (phase === "Build") {
         const t = phaseLength > 1 ? weekInPhase / (phaseLength - 1) : 1;
         return clamp(Math.round((135 + t * (180 - 135)) / 5) * 5, 135, 180);
      }
      if (phase === "Peak") return 190;
      // Taper long run
      // Original: 120, 100, 70 (approx)
      const t = phaseLength > 1 ? weekInPhase / (phaseLength - 1) : 1;
      return clamp(Math.round((120 - t * (120 - 70)) / 5) * 5, 70, 120);
    })();
    const longMin = isRecovery && phase !== "Taper" ? Math.round(longMinByPhase * 0.75) : longMinByPhase;

    const tuesdayKey = (() => {
      if (phase === "Taper") return { title: "Sharpening Intervals", minutes: 55, detailsTemplate: "WU 15m • 6×400m @ {INTERVALS} • CD 10m" };
      if (isRecovery) return { title: "Light Fartlek", minutes: 50, detailsTemplate: "Easy 15m • 6×1m steady (~{TEMPO}) w/ 1m easy" };
      return { title: "Intervals", minutes: phase === "Base" ? 55 : 65, detailsTemplate: "WU 15m • 5–8×3m @ {INTERVALS} w/ 2m easy • CD 10m" };
    })();

    const thursdayKey = (() => {
      if (phase === "Taper") return { title: "Marathon Pace Tune-up", minutes: 60, detailsTemplate: "WU 15m • 2×10m @ MP ({MP}) w/ 5m easy • CD" };
      if (phase === "Peak") return { title: "Extended MP", minutes: 80, detailsTemplate: "WU 15m • 40m @ MP ({MP}) • CD 10m" };
      if (isRecovery) return { title: "Steady Aerobic", minutes: 65, detailsTemplate: "Mostly easy ({EASY}). Finish 10m steady." };
      return { title: "Tempo / MP Blend", minutes: phase === "Base" ? 70 : 75, detailsTemplate: "WU 15m • 20m tempo ({TEMPO}) then 15m @ MP • CD" };
    })();

    const fixed = tuesdayKey.minutes + thursdayKey.minutes + longMin;
    const remaining = Math.max(0, runMin - fixed);
    const wedMin = clamp(Math.round(remaining * 0.35), 35, 70);
    const friMin = clamp(Math.round(remaining * 0.3), 30, 60);
    const sunMin = clamp(remaining - wedMin - friMin, 25, 60);

    const days = Array.from({ length: 7 }, (_, i) => ({ dayIndex: i, sessions: [], isLongRunDay: false }));

    days[0].sessions.push({ id: uid("rest"), sport: "rest", title: "Rest / Mobility", minutes: 0, intensity: "recovery", optional: false, details: "Off feet. 10–15m mobility: calves, hips, hamstrings, T-spine.", status: "planned", moved: false });
    days[0].sessions.push({ id: uid("str"), sport: "strength", title: "Strength (light)", minutes: 25, intensity: "recovery", optional: true, details: "20–30m: single-leg, glutes, core. Keep it easy.", status: "planned", moved: false });

    days[1].sessions.push({ id: uid("run"), sport: "run", title: tuesdayKey.title, minutes: tuesdayKey.minutes, intensity: "key", optional: false, detailsTemplate: tuesdayKey.detailsTemplate, status: "planned", moved: false });
    days[1].sessions.push({ id: uid("sw"), sport: "swim", title: "Swim (easy recovery)", minutes: 25, intensity: "recovery", optional: true, details: "Easy continuous + drills. Keep HR low.", status: "planned", moved: false });

    days[2].sessions.push({ id: uid("run"), sport: "run", title: "Easy Run", minutes: wedMin, intensity: "easy", optional: false, detailsTemplate: "Easy {EASY}. Add 6×20s strides if fresh.", status: "planned", moved: false });
    days[2].sessions.push({ id: uid("str"), sport: "strength", title: "Strength (optional)", minutes: 20, intensity: "recovery", optional: true, details: "Core + hips. Avoid heavy legs midweek.", status: "planned", moved: false });

    days[3].sessions.push({ id: uid("run"), sport: "run", title: thursdayKey.title, minutes: thursdayKey.minutes, intensity: "key", optional: false, detailsTemplate: thursdayKey.detailsTemplate, status: "planned", moved: false });
    days[3].sessions.push({ id: uid("bk"), sport: "bike", title: "Bike (easy spin)", minutes: 30, intensity: "recovery", optional: true, details: "Z1–Z2, high cadence. Pure recovery.", status: "planned", moved: false });

    days[4].sessions.push({ id: uid("run"), sport: "run", title: "Easy + Strides", minutes: friMin, intensity: "easy", optional: false, detailsTemplate: "Easy {EASY}. Finish 6×15s strides.", status: "planned", moved: false });
    days[4].sessions.push({ id: uid("sw"), sport: "swim", title: "Swim (easy)", minutes: 20, intensity: "recovery", optional: true, details: "Relaxed swim or pool walk. Keep it easy.", status: "planned", moved: false });

    const longDetails = (() => {
      if (phase === "Peak" && !isRecovery) return "Long run {LONG}. Include 2×20m @ MP ({MP}) w/ 10m easy between. Practice fueling.";
      if (phase === "Build" && !isRecovery) return "Long run {LONG}. Last 20m slightly faster if good (≤ MP).";
      if (phase === "Taper") return "Long run {LONG}. Comfortable. No hero efforts.";
      return "Long run {LONG}. Conversational. Fuel 30–60g carbs/hour + fluids.";
    })();

    days[longRunDayIndex].sessions.push({ id: uid("run"), sport: "run", title: `Long Run (${DAY_NAMES[longRunDayIndex]})`, minutes: longMin, intensity: "key", optional: false, detailsTemplate: longDetails, status: "planned", moved: false });
    days[longRunDayIndex].isLongRunDay = true;
    days[longRunDayIndex].sessions.push({ id: uid("bk"), sport: "bike", title: "Bike (optional flush)", minutes: 25, intensity: "recovery", optional: true, details: "Very easy spin later if legs feel heavy.", status: "planned", moved: false });

    days[recoveryRunDay].sessions.push({ id: uid("run"), sport: "run", title: "Recovery Run", minutes: sunMin, intensity: "easy", optional: false, detailsTemplate: "Very easy {EASY}. Keep it gentle.", status: "planned", moved: false });
    days[6].sessions.push({ id: uid("sw"), sport: "swim", title: "Swim (recovery)", minutes: 20, intensity: "recovery", optional: true, details: "Easy technique + mobility in the water.", status: "planned", moved: false });

    applyCrossTrainingPreferences(days, settings.crossTraining);

    const phaseNote = (() => {
      if (phase === "Base") return "Base: build consistency. Keep easy days easy.";
      if (phase === "Build") return "Build: longer workouts. Fuel + recover.";
      if (phase === "Peak") return "Peak: practice MP + fueling. Respect fatigue.";
      return "Taper: reduce volume, keep a touch of intensity, sleep.";
    })();

    return { weekIndex, phase: `${phase}${isRecovery ? " (Recovery)" : ""} • ${phaseNote}`, days };
  }

  function generatePlan(ctx = { pace: PACE, settings: currentSettings, config: CONFIG }) {
    const weeks = [];
    const structure = getPlanStructure(ctx.config.weeks);
    for (let i = 0; i < ctx.config.weeks; i++) weeks.push(generateWeek(i, { ...ctx, structure }));
    return weeks;
  }

  // =============================
  // Persistence
  // =============================
  function loadState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (parsed.signature && parsed.signature !== currentSignature) return null;
      return parsed;
    } catch {
      return null;
    }
  }
  function saveState(state) { try { localStorage.setItem(STORAGE_KEY, JSON.stringify({ ...state, signature: currentSignature })); } catch {} }

  // =============================
  // Adaptation / reschedule logic
  // =============================
  function findSession(week, sessionId) {
    for (const d of week.days) {
      const s = d.sessions.find((x) => x.id === sessionId);
      if (s) return { day: d, session: s };
    }
    return null;
  }
  function dayHasKeyRun(day) { return day.sessions.some(isKeyRun); }
  function moveSession(week, fromDayIndex, toDayIndex, sessionId) {
    const from = week.days[fromDayIndex];
    const to = week.days[toDayIndex];
    const idx = from.sessions.findIndex((s) => s.id === sessionId);
    if (idx === -1) return false;
    const [s] = from.sessions.splice(idx, 1);
    s.moved = true;
    to.sessions.unshift(s);
    return true;
  }
  function convertToEasyRun(session) {
    session.title = "Converted Easy Run";
    session.intensity = "easy";
    session.minutes = clamp(session.minutes, 30, 45);
    session.detailsTemplate = "Easy {EASY}. This replaced a missed key session.";
    session.details = session.detailsTemplate;
    session.moved = true;
  }
  function applyMissedAdaptiveRule(plan, weekIndex, sessionId) {
    const week = plan[weekIndex];
    const found = findSession(week, sessionId);
    if (!found) return;
    const fromDayIndex = found.day.dayIndex;
    const s = found.session;
    if (!isKeyRun(s)) return;

    const candidates = [];
    if (fromDayIndex === Number(currentSettings.longRunDay)) candidates.push((fromDayIndex + 1) % 7);
    for (let step = 1; step <= 6; step++) candidates.push((fromDayIndex + step) % 7);

    for (const toDayIndex of candidates) {
      if (toDayIndex === fromDayIndex) continue;
      if (toDayIndex === 0) continue;
      const toDay = week.days[toDayIndex];
      if (dayHasKeyRun(toDay)) continue;
      if (moveSession(week, fromDayIndex, toDayIndex, sessionId)) {
        toast(`Moved key session to ${DAY_NAMES[toDayIndex]}.`);
        return;
      }
    }

    convertToEasyRun(s);
    toast("Couldn’t reschedule safely — converted to an easy run.");
  }

  // =============================
  // Rendering + interaction
  // =============================
  const el = {
    weekSelect: document.getElementById("weekSelect"),
    prevWeek: document.getElementById("prevWeek"),
    nextWeek: document.getElementById("nextWeek"),
    reset: document.getElementById("reset"),
    tests: document.getElementById("tests"),
    weekTitle: document.getElementById("weekTitle"),
    weekPhase: document.getElementById("weekPhase"),
    weekTotals: document.getElementById("weekTotals"),
    weekGrid: document.getElementById("weekGrid"),
    toast: document.getElementById("toast"),
    selTitle: document.getElementById("selTitle"),
    selSub: document.getElementById("selSub"),
    btnCompact: document.getElementById("btnCompact"),
    btnDetailed: document.getElementById("btnDetailed"),
    subtitle: document.getElementById("subtitle"),
    paceGuide: document.getElementById("paceGuide"),
    weekLabel: document.getElementById("weekLabel"),
    personalizationForm: document.getElementById("personalizationForm"),
    raceDate: document.getElementById("raceDate"),
    planLength: document.getElementById("planLength"),
    goalTime: document.getElementById("goalTime"),
    recentTime: document.getElementById("recentTime"),
    longRunDay: document.getElementById("longRunDay"),
    bikeEnabled: document.getElementById("bikeEnabled"),
    bikeMinutes: document.getElementById("bikeMinutes"),
    swimEnabled: document.getElementById("swimEnabled"),
    swimMinutes: document.getElementById("swimMinutes"),
    strengthEnabled: document.getElementById("strengthEnabled"),
    strengthMinutes: document.getElementById("strengthMinutes"),
    paceSource: document.getElementById("paceSource"),
    trialDistance: document.getElementById("trialDistance"),
    trialTime: document.getElementById("trialTime"),
    adjustment: document.getElementById("adjustment"),
    adjustmentValue: document.getElementById("adjustmentValue"),
    unitKm: document.getElementById("unitKm"),
    unitMi: document.getElementById("unitMi"),
    themeSelect: document.getElementById("themeSelect"),
    maxHr: document.getElementById("maxHr"),
    easyHr: document.getElementById("easyHr"),
    weekStatusPill: document.getElementById("weekStatusPill"),
    weekStatusText: document.getElementById("weekStatusText"),
    mobileViewToggle: document.getElementById("mobileViewToggle"),
    btnSummary: document.getElementById("btnSummary"),
    btnWeekDetailed: document.getElementById("btnWeekDetailed"),
  };

  const UI = loadUIState();
  function setMode(detailed) {
    UI.detailed = detailed;
    if (el.btnCompact) el.btnCompact.setAttribute("data-active", String(!detailed));
    if (el.btnDetailed) el.btnDetailed.setAttribute("data-active", String(!!detailed));
    saveUIState(UI);
  }

  function toast(msg) {
    el.toast.textContent = msg;
    el.toast.classList.add("show");
    clearTimeout(toast._t);
    toast._t = setTimeout(() => el.toast.classList.remove("show"), 2200);
  }

  function updateSubtitle() {
    if (!el.subtitle) return;
    const longDay = LONG_DAY_NAMES[Number(currentSettings.longRunDay)] || "Saturday";
    el.subtitle.textContent = `${CONFIG.weeks} weeks • Goal ${currentSettings.goalTime} • Long run ${longDay} • Mark sessions Done/Missed to adapt`;
  }

  function paceRangeLabel(key, unit = currentUnit) {
    const range = PACE && PACE[key ? key.toLowerCase() : ""];
    if (!range) return "-";
    return fmtRange(range, unit);
  }

  function formatDetails(template) {
    if (!template) return "";
    const replacements = {
      EASY: paceRangeLabel("easy"),
      LONG: paceRangeLabel("long"),
      MP: paceRangeLabel("mp"),
      TEMPO: paceRangeLabel("tempo"),
      INTERVALS: paceRangeLabel("intervals") || paceRangeLabel("int"),
    };
    return template.replace(/\{(EASY|LONG|MP|TEMPO|INTERVALS)\}/g, (_, key) => replacements[key] || "");
  }

  function renderPaceGuide(collapsed = UI.paceCollapsed) {
    if (!el.paceGuide) return;
    UI.paceCollapsed = collapsed;
    saveUIState(UI);
    const adj = Number(currentSettings.adjustment) || 0;
    const baseMp = BASE_ZONES?.mp?.[0] || 0;
    const pct = baseMp ? Math.round((adj / baseMp) * 1000) / 10 : 0;
    const adjLabel = `${adj >= 0 ? "+" : ""}${adj} sec/km ${pct ? `(~${pct}% )` : ""}`;
    const hrNote = currentSettings.easyHr || currentSettings.maxHr ? `<div class="note">Use HR cap for easy/long: ${currentSettings.easyHr || ""}${currentSettings.easyHr && currentSettings.maxHr ? " bpm of " : ""}${currentSettings.maxHr ? `${currentSettings.maxHr} max` : ""}</div>` : "";
    const guideBody = `
      <div class="title">Pace guide (${currentUnit})</div>
      <div class="note">Adjustment: ${adjLabel}</div>
      <div>Easy: <b>${paceRangeLabel("easy")}</b> • Long: <b>${paceRangeLabel("long")}</b></div>
      <div>Marathon pace (MP): <b>${paceRangeLabel("mp")}</b></div>
      <div>Threshold/Tempo: <b>${paceRangeLabel("tempo")}</b> • Intervals: <b>${paceRangeLabel("intervals")}</b></div>
      ${hrNote}
    `;
    const detailsId = "paceGuideDetails";
    el.paceGuide.innerHTML = `
      <button class="pace-toggle" id="paceToggle" aria-expanded="${!collapsed}" aria-controls="${detailsId}" data-open="${!collapsed}">
        <span class="label"><b>Pace guide</b><span>Easy / Long / MP / Tempo / Intervals</span></span>
        <span class="chevron">⌄</span>
      </button>
      <div id="${detailsId}" style="display:${collapsed ? "none" : "block"};">${guideBody}</div>
    `;
    const toggle = document.getElementById("paceToggle");
    const details = document.getElementById(detailsId);
    if (toggle && details) {
      const toggleOpen = () => {
        const next = details.style.display === "none";
        renderPaceGuide(!next);
      };
      toggle.addEventListener("click", toggleOpen);
      toggle.addEventListener("keydown", (e) => { if (e.key === "Enter" || e.key === " ") { e.preventDefault(); toggleOpen(); } });
    }
  }

  function updateAdjustmentLabel(val = currentSettings.adjustment) {
    if (!el.adjustmentValue) return;
    const num = Number(val) || 0;
    const miAdj = Math.round(num * 1.609344);
    el.adjustmentValue.textContent = `${num >= 0 ? "+" : ""}${num} sec/km (${miAdj >= 0 ? "+" : ""}${miAdj} sec/mi)`;
  }

  function updateUnitButtons(unit) {
    if (!el.unitKm || !el.unitMi) return;
    el.unitKm.setAttribute("data-active", String(unit === "km"));
    el.unitMi.setAttribute("data-active", String(unit === "mi"));
  }

  function updatePaceSourceVisibility(source = currentSettings.paceSource) {
    const show = source === "trial";
    const distWrap = document.getElementById("trialDistanceWrap");
    const timeWrap = document.getElementById("trialTimeWrap");
    if (distWrap) distWrap.style.display = show ? "block" : "none";
    if (timeWrap) timeWrap.style.display = show ? "block" : "none";
  }

  function syncForm(settings) {
    if (!el.personalizationForm) return;
    el.raceDate.value = settings.raceDate;
    el.planLength.value = settings.planLength === "" ? "" : settings.planLength;
    el.goalTime.value = settings.goalTime;
    el.recentTime.value = settings.recentTime;
    el.longRunDay.value = settings.longRunDay;
    el.bikeEnabled.checked = settings.crossTraining.bike.enabled;
    el.bikeMinutes.value = settings.crossTraining.bike.minutes;
    el.swimEnabled.checked = settings.crossTraining.swim.enabled;
    el.swimMinutes.value = settings.crossTraining.swim.minutes;
    el.strengthEnabled.checked = settings.crossTraining.strength.enabled;
    el.strengthMinutes.value = settings.crossTraining.strength.minutes;
    el.paceSource.value = settings.paceSource;
    el.trialDistance.value = settings.trialDistance;
    el.trialTime.value = settings.trialTime;
    el.adjustment.value = settings.adjustment;
    el.themeSelect.value = settings.theme;
    el.maxHr.value = settings.maxHr;
    el.easyHr.value = settings.easyHr;
    updateUnitButtons(settings.unit);
    updateAdjustmentLabel(settings.adjustment);
    updatePaceSourceVisibility(settings.paceSource);
  }

  function applySettings(settings, opts = { updateUI: true }) {
    currentSettings = normalizeSettings(settings);
    CONFIG = buildConfigFromSettings(currentSettings);
    BASE_ZONES = computeZonesFromSettings(currentSettings);
    PACE = applyAdjustment(BASE_ZONES, currentSettings.adjustment);
    currentUnit = currentSettings.unit;
    currentSignature = settingsSignature(currentSettings, CONFIG);
    if (currentSettings.theme) {
      document.documentElement.setAttribute("data-theme", currentSettings.theme);
    }
    if (opts.updateUI) {
      syncForm(currentSettings);
      renderPaceGuide();
      updateSubtitle();
    }
  }

  function collectSettingsFromForm() {
    const goalVal = el.goalTime.value.trim() || DEFAULT_SETTINGS.goalTime;
    const recentVal = el.recentTime.value.trim() || DEFAULT_SETTINGS.recentTime;
    const goalSec = parseTimeInput(goalVal);
    const recentSec = parseTimeInput(recentVal);
    if (!goalSec) throw new Error("Goal time must be hh:mm or hh:mm:ss");
    if (!recentSec) throw new Error("Recent race time must be hh:mm or hh:mm:ss");
    const planLengthVal = el.planLength.value.trim();
    if (planLengthVal && (!Number.isFinite(Number(planLengthVal)) || Number(planLengthVal) <= 0)) throw new Error("Plan length must be a positive number");
    const raceDateVal = el.raceDate.value;
    if (raceDateVal) {
      const d = new Date(raceDateVal);
      if (Number.isNaN(d.getTime())) throw new Error("Race date is invalid");
    }
    const minutesOrDefault = (input, fallback) => {
      const raw = input.value.trim();
      if (raw === "") return fallback;
      const num = Number(raw);
      if (!Number.isFinite(num) || num < 0) throw new Error("Cross-training minutes must be zero or positive");
      return num;
    };
    const trialVal = el.trialTime.value.trim() || DEFAULT_SETTINGS.trialTime;
    const trialSec = parseTimeInput(trialVal);
    if (el.paceSource.value === "trial" && !trialSec) throw new Error("Custom time trial time must be hh:mm or hh:mm:ss");
    return normalizeSettings({
      raceDate: raceDateVal,
      planLength: planLengthVal === "" ? "" : Number(planLengthVal),
      goalTime: goalVal,
      recentTime: recentVal,
      longRunDay: el.longRunDay.value,
      paceSource: el.paceSource.value,
      trialDistance: el.trialDistance.value,
      trialTime: trialVal,
      adjustment: Number(el.adjustment.value) || 0,
      unit: currentUnit,
      theme: el.themeSelect.value,
      maxHr: el.maxHr.value,
      easyHr: el.easyHr.value,
      crossTraining: {
        bike: { enabled: el.bikeEnabled.checked, minutes: minutesOrDefault(el.bikeMinutes, DEFAULT_SETTINGS.crossTraining.bike.minutes) },
        swim: { enabled: el.swimEnabled.checked, minutes: minutesOrDefault(el.swimMinutes, DEFAULT_SETTINGS.crossTraining.swim.minutes) },
        strength: { enabled: el.strengthEnabled.checked, minutes: minutesOrDefault(el.strengthMinutes, DEFAULT_SETTINGS.crossTraining.strength.minutes) },
      },
    });
  }

  function rebuildPlan(settings) {
    applySettings(settings);
    savePersonalizationSettings(currentSettings);
    state = { plan: generatePlan({ pace: PACE, settings: currentSettings, config: CONFIG }), activeWeek: 0, selected: { weekIndex: 0, sessionId: null } };
    selected = state.selected;
    bindWeekSelect();
    renderWeek(state.plan, state.activeWeek);
    saveState({ plan: state.plan, activeWeek: state.activeWeek, selected });
    toast("Plan regenerated");
  }

  function refreshPaces(partial = {}) {
    applySettings({ ...currentSettings, ...partial });
    renderWeek(state.plan, state.activeWeek);
    savePersonalizationSettings(currentSettings);
    saveState({ plan: state.plan, activeWeek: state.activeWeek, selected });
  }

  function sportBadge(s) {
    const sport = s.sport === "run" ? "Run" : s.sport === "bike" ? "Bike" : s.sport === "swim" ? "Swim" : s.sport === "strength" ? "Strength" : s.sport === "rest" ? "Rest" : s.sport;
    const mins = s.minutes ? ` • ${minToText(s.minutes)}` : "";
    const opt = s.optional ? " • opt" : "";
    const mv = s.moved ? " • moved" : "";
    return `${sport}${mins}${opt}${mv}`;
  }

  function computeWeekTotals(week) {
    let run = 0, bike = 0, swim = 0, str = 0;
    for (const d of week.days) {
      for (const s of d.sessions) {
        if (s.status === "missed") continue;
        if (s.sport === "run") run += s.minutes;
        if (s.sport === "bike") bike += s.minutes;
        if (s.sport === "swim") swim += s.minutes;
        if (s.sport === "strength") str += s.minutes;
      }
    }
    return { run, bike, swim, str, total: run + bike + swim + str };
  }

  // =============================
  // Week Status Computation
  // =============================
  function getWeekStatus(week, today = new Date()) {
    const t = new Date(today);
    t.setHours(0, 0, 0, 0);
    const todayIdx = (t.getDay() + 6) % 7;
    if (week.weekIndex > 0) return "future";
    const sessionsUpToToday = [];
    for (const d of week.days) {
      if (week.weekIndex === 0 && d.dayIndex > todayIdx) continue;
      sessionsUpToToday.push(...d.sessions);
    }
    if (!sessionsUpToToday.length) return "future";
    const missed = sessionsUpToToday.some((s) => s.status === "missed");
    const planned = sessionsUpToToday.filter((s) => s.status === "planned");
    const done = sessionsUpToToday.filter((s) => s.status === "done");
    if (missed) return "missed";
    if (!planned.length) return "completed";
    if (done.length) return "partial";
    return "partial";
  }
  const WEEK_STATUS_META = {
    completed: { text: "On track", dotClass: "status-green", tooltip: "All sessions through today are done" },
    partial: { text: "Partial", dotClass: "status-yellow", tooltip: "Some sessions done, some remaining" },
    missed: { text: "Missed", dotClass: "status-red", tooltip: "One or more sessions missed" },
    future: { text: "Upcoming", dotClass: "status-gray", tooltip: "Week is in the future" },
  };
  function statusIcon(status) { return status === "completed" ? "🟢" : status === "partial" ? "🟡" : status === "missed" ? "🔴" : "⚪"; }
  function applyWeekStatusUI(status) {
    const meta = WEEK_STATUS_META[status] || WEEK_STATUS_META.future;
    if (el.weekStatusText) el.weekStatusText.textContent = meta.text;
    if (el.weekStatusPill) {
      el.weekStatusPill.title = meta.tooltip;
      el.weekStatusPill.querySelectorAll(".status-dot").forEach((n) => {
        n.className = `status-dot ${meta.dotClass}`;
      });
    }
  }

  // =============================
  // Mobile Summary Rendering
  // =============================
  function summarizeStatus(day) {
    if (day.sessions.some((s) => s.status === "missed")) return "missed";
    if (day.sessions.some((s) => s.status === "done")) return "done";
    return "planned";
  }
  function renderWeekSummary(week) {
    const container = document.createElement("div");
    container.className = "week-summary";
    const totals = computeWeekTotals(week);
    container.innerHTML = `
      <div class="week-summary-header">Week at a glance <span class="muted">Tap a day to drill in</span></div>
      <div class="week-summary-list"></div>
      <div class="week-summary-totals">Totals: Run ${minToText(totals.run)} • Bike ${minToText(totals.bike)} • Swim ${minToText(totals.swim)} • Strength ${minToText(totals.str)} • All ${minToText(totals.total)}</div>
    `;
    const list = container.querySelector(".week-summary-list");
    week.days.forEach((d) => {
      const keySession = d.sessions.find((s) => isKeyRun(s)) || d.sessions.find((s) => s.sport === "run") || d.sessions[0];
      const status = summarizeStatus(d);
      const row = document.createElement("div");
      row.className = "week-summary-row";
      row.innerHTML = `
        <div class="day ${d.isLongRunDay ? "summary-long" : ""}">${DAY_NAMES[d.dayIndex]}</div>
        <div class="label">${escapeHtml(keySession?.title || "Rest")}</div>
        <div class="minutes">${minToText(keySession?.minutes || 0)}</div>
        <div class="status-chip" data-status="${status}">${status}</div>
      `;
      row.addEventListener("click", () => { setSummaryMode(false, d.dayIndex); });
      list.appendChild(row);
    });
    return container;
  }

  let selected = { weekIndex: 0, sessionId: null };
  function setSelected(weekIndex, session) {
    selected.weekIndex = weekIndex;
    selected.sessionId = session.id;
    el.selTitle.textContent = session.title;
    el.selSub.textContent = sportBadge(session);
  }
  function clearSelectionUI() { el.weekGrid.querySelectorAll(".session").forEach((n) => n.setAttribute("data-selected", "false")); }

  function renderWeek(plan, weekIndex) {
    const w = plan[weekIndex];
    if (el.weekLabel) el.weekLabel.textContent = `Week ${weekIndex + 1} of ${CONFIG.weeks}`;
    el.weekPhase.textContent = w.phase;
    const status = getWeekStatus(w);
    applyWeekStatusUI(status);
    const useSummary = isMobile() && UI.summaryMobile;
    if (el.btnSummary) el.btnSummary.setAttribute("data-active", String(useSummary));
    if (el.btnWeekDetailed) el.btnWeekDetailed.setAttribute("data-active", String(!useSummary));
    if (el.mobileViewToggle) el.mobileViewToggle.style.display = isMobile() ? "flex" : "none";

    const totals = computeWeekTotals(w);
    el.weekTotals.textContent = `Totals (excl. missed): Run ${minToText(totals.run)} • Bike ${minToText(totals.bike)} • Swim ${minToText(totals.swim)} • Strength ${minToText(totals.str)} • All ${minToText(totals.total)}`;

    el.weekGrid.innerHTML = "";
    if (useSummary) {
      el.weekGrid.appendChild(renderWeekSummary(w));
      return;
    }
    for (const d of w.days) {
      const dayEl = document.createElement("div");
      dayEl.className = "day-card";
      dayEl.setAttribute("data-day-index", String(d.dayIndex));
      const nonMissedRunMin = d.sessions.filter((s) => s.sport === "run" && s.status !== "missed").reduce((a, b) => a + b.minutes, 0);
      const nonMissedTotal = d.sessions.filter((s) => s.status !== "missed").reduce((a, b) => a + b.minutes, 0);
      const sessionCount = d.sessions.length;

      dayEl.innerHTML = `
        <div class="day-rail">
          <div class="day-name">${DAY_NAMES[d.dayIndex]}</div>
          <div class="day-meta">${nonMissedRunMin ? `${minToText(nonMissedRunMin)} run` : "—"}</div>
          <div class="day-meta">${nonMissedTotal ? `${minToText(nonMissedTotal)} all • ${sessionCount} session${sessionCount !== 1 ? "s" : ""}` : `${sessionCount} session${sessionCount !== 1 ? "s" : ""}`}</div>
          ${d.isLongRunDay ? '<div class="long-chip">Long run</div>' : ""}
        </div>
        <div class="day-body"></div>
      `;

      const body = dayEl.querySelector(".day-body");
      const primary = (() => { const p = d.sessions.find((s) => s.sport === "run" && !s.optional); return p || d.sessions[0]; })();
      const recovery = d.sessions.filter((s) => s.id !== primary.id);

      const colPrimary = document.createElement("div");
      colPrimary.className = "col primary";
      colPrimary.innerHTML = '<div class="section-label"><span>Primary</span><span class="muted">Tap to expand</span></div>';
      colPrimary.appendChild(renderSessionCard(primary, weekIndex));
      body.appendChild(colPrimary);

      const colRecovery = document.createElement("div");
      colRecovery.className = "col recovery";
      if (recovery.length) {
        const group = document.createElement("div");
        group.className = "recovery-group";
        group.setAttribute("data-open", "false");
        group.innerHTML = `
          <div class="recovery-header" role="button" aria-expanded="false" tabindex="0">
            <span>Recovery / Optional</span>
            <span class="recovery-count">${recovery.length}</span>
          </div>
          <div class="recovery-body"></div>
        `;
        const hdr = group.querySelector(".recovery-header");
        const bodyGroup = group.querySelector(".recovery-body");
        const toggleRecovery = () => {
          const open = group.getAttribute("data-open") === "true";
          group.setAttribute("data-open", String(!open));
          hdr.setAttribute("aria-expanded", String(!open));
        };
        hdr.addEventListener("click", toggleRecovery);
        hdr.addEventListener("keydown", (e) => { if (e.key === "Enter" || e.key === " ") { e.preventDefault(); toggleRecovery(); } });
        for (const s of recovery) bodyGroup.appendChild(renderSessionCard(s, weekIndex));
        colRecovery.appendChild(group);
      } else {
        colRecovery.innerHTML = '<div class="section-label"><span>Recovery</span><span class="muted">None</span></div>';
      }
      body.appendChild(colRecovery);

      el.weekGrid.appendChild(dayEl);
    }

    clearSelectionUI();
    if (selected.weekIndex === weekIndex && selected.sessionId) {
      const node = el.weekGrid.querySelector(`.session[data-sid="${selected.sessionId}"]`);
      if (node) node.setAttribute("data-selected", "true");
    }
  }

  function renderSessionCard(session, weekIndex) {
    const sEl = document.createElement("div");
    sEl.className = "session";
    sEl.setAttribute("data-sid", session.id);
    sEl.setAttribute("data-open", String(UI.detailed));
    sEl.setAttribute("data-selected", "false");
    sEl.setAttribute("data-status", session.status);

    const key = isKeyRun(session) ? "Key" : session.sport === "run" ? "Easy" : "Recovery";
    const detailText = formatDetails(session.detailsTemplate || session.details || "");
    sEl.innerHTML = `
      <div class="session-head" role="button" aria-expanded="${UI.detailed}" tabindex="0">
        <div style="min-width:0">
          <div class="session-title">${escapeHtml(session.title)}</div>
          <div class="session-sub">${escapeHtml(key)} • ${escapeHtml(sportBadge(session))}</div>
        </div>
        <span class="chip">${escapeHtml(session.status)}</span>
      </div>
      <div class="details">${escapeHtml(detailText)}</div>
    `;

    const top = sEl.querySelector(".session-head");
    const toggleOpen = () => { const open = sEl.getAttribute("data-open") === "true"; sEl.setAttribute("data-open", String(!open)); top.setAttribute("aria-expanded", String(!open)); };

    top.addEventListener("click", (e) => { e.stopPropagation(); clearSelectionUI(); sEl.setAttribute("data-selected", "true"); setSelected(weekIndex, session); toggleOpen(); });
    top.addEventListener("keydown", (e) => { if (e.key === "Enter" || e.key === " ") { e.preventDefault(); clearSelectionUI(); sEl.setAttribute("data-selected", "true"); setSelected(weekIndex, session); toggleOpen(); } });
    sEl.addEventListener("click", () => { clearSelectionUI(); sEl.setAttribute("data-selected", "true"); setSelected(weekIndex, session); });

    return sEl;
  }

  function setSessionStatus(plan, weekIndex, sessionId, status) {
    const w = plan[weekIndex];
    const found = findSession(w, sessionId);
    if (!found) return;
    const s = found.session;
    const prev = s.status;
    s.status = status;
    if (prev !== "missed" && status === "missed") applyMissedAdaptiveRule(plan, weekIndex, sessionId);
    saveState({ plan, activeWeek: weekIndex, selected });
    renderWeek(plan, weekIndex);
    bindWeekSelect();
  }

  function setSummaryMode(summary, targetDay) {
    UI.summaryMobile = summary;
    saveUIState(UI);
    renderWeek(state.plan, state.activeWeek);
    if (!summary && typeof targetDay === "number") {
      const node = el.weekGrid.querySelector(`[data-day-index="${targetDay}"]`);
      if (node) node.scrollIntoView({ behavior: "smooth", block: "start" });
    }
  }

  function initState() {
    const fresh = { plan: generatePlan({ pace: PACE, settings: currentSettings, config: CONFIG }), activeWeek: 0, selected: { weekIndex: 0, sessionId: null } };
    const saved = loadState();
    if (saved && saved.plan && Array.isArray(saved.plan) && saved.plan.length === CONFIG.weeks) {
      return { plan: saved.plan, activeWeek: typeof saved.activeWeek === "number" ? saved.activeWeek : 0, selected: saved.selected || { weekIndex: 0, sessionId: null } };
    }
    return fresh;
  }

  applySettings(currentSettings);
  let state = initState();
  selected = state.selected;

  function bindWeekSelect() {
    el.weekSelect.innerHTML = "";
    const structure = getPlanStructure(CONFIG.weeks);
    for (let i = 0; i < CONFIG.weeks; i++) {
      const opt = document.createElement("option");
      opt.value = String(i);
      const week = state.plan?.[i];
      const status = week ? getWeekStatus(week) : "future";
      opt.textContent = `${statusIcon(status)} Week ${i + 1} • ${weekPhase(i, structure)}`;
      const meta = WEEK_STATUS_META[status];
      if (meta) opt.title = meta.tooltip;
      el.weekSelect.appendChild(opt);
    }
    el.weekSelect.value = String(state.activeWeek);
    el.weekSelect.onchange = () => { state.activeWeek = Number(el.weekSelect.value); saveState({ plan: state.plan, activeWeek: state.activeWeek, selected }); renderWeek(state.plan, state.activeWeek); };
  }

  function changeWeek(delta) {
    state.activeWeek = clamp(state.activeWeek + delta, 0, CONFIG.weeks - 1);
    el.weekSelect.value = String(state.activeWeek);
    saveState({ plan: state.plan, activeWeek: state.activeWeek, selected });
    renderWeek(state.plan, state.activeWeek);
  }

  el.prevWeek.addEventListener("click", () => changeWeek(-1));
  el.nextWeek.addEventListener("click", () => changeWeek(1));

  document.querySelectorAll(".btn-row button[data-set]").forEach((btn) => {
    btn.addEventListener("click", () => { if (!selected.sessionId) return; setSessionStatus(state.plan, state.activeWeek, selected.sessionId, btn.getAttribute("data-set")); });
  });

  el.reset.addEventListener("click", () => {
    if (!confirm("Reset all progress and moved sessions?")) return;
    localStorage.removeItem(STORAGE_KEY);
    state = initState();
    selected = state.selected;
    bindWeekSelect();
    renderWeek(state.plan, state.activeWeek);
    toast("Progress reset.");
  });

  if (el.personalizationForm) {
    el.personalizationForm.addEventListener("submit", (e) => {
      e.preventDefault();
      try {
        const settings = collectSettingsFromForm();
        rebuildPlan(settings);
      } catch (err) {
        const msg = err && err.message ? err.message : String(err);
        alert(msg);
        toast("Please fix personalization inputs");
      }
    });
    el.paceSource.addEventListener("change", () => {
      updatePaceSourceVisibility(el.paceSource.value);
      refreshPaces({ paceSource: el.paceSource.value, trialDistance: el.trialDistance.value, trialTime: el.trialTime.value || currentSettings.trialTime });
    });
    el.trialDistance.addEventListener("change", () => refreshPaces({ trialDistance: el.trialDistance.value }));
    el.trialTime.addEventListener("change", () => refreshPaces({ trialTime: el.trialTime.value || currentSettings.trialTime }));
    el.adjustment.addEventListener("input", () => updateAdjustmentLabel(el.adjustment.value));
    el.adjustment.addEventListener("change", () => refreshPaces({ adjustment: Number(el.adjustment.value) || 0 }));
    el.themeSelect.addEventListener("change", () => {
      const theme = el.themeSelect.value;
      currentSettings.theme = theme;
      document.documentElement.setAttribute("data-theme", theme);
      savePersonalizationSettings(currentSettings);
      toast("Theme updated");
    });
    el.unitKm.addEventListener("click", () => { if (currentSettings.unit !== "km") refreshPaces({ unit: "km" }); });
    el.unitMi.addEventListener("click", () => { if (currentSettings.unit !== "mi") refreshPaces({ unit: "mi" }); });
    [el.maxHr, el.easyHr].forEach((node) => node.addEventListener("change", () => refreshPaces({ maxHr: el.maxHr.value, easyHr: el.easyHr.value })));
  }

  window.addEventListener("keydown", (e) => { if (e.key === "ArrowLeft") changeWeek(-1); if (e.key === "ArrowRight") changeWeek(1); });

  if (el.btnCompact && el.btnDetailed) {
    el.btnCompact.addEventListener("click", () => { setMode(false); renderWeek(state.plan, state.activeWeek); });
    el.btnDetailed.addEventListener("click", () => { setMode(true); renderWeek(state.plan, state.activeWeek); });
    setMode(UI.detailed);
  }
  if (el.btnSummary && el.btnWeekDetailed) {
    el.btnSummary.addEventListener("click", () => setSummaryMode(true));
    el.btnWeekDetailed.addEventListener("click", () => setSummaryMode(false));
  }

  // =============================
  // Tests
  // =============================
  function assert(name, cond) { if (!cond) throw new Error(`Test failed: ${name}`); }
  function generatePlanWithSettings(overrides = {}) {
    const mergedCross = { ...currentSettings.crossTraining, ...(overrides.crossTraining || {}) };
    const merged = normalizeSettings({ ...currentSettings, ...overrides, crossTraining: mergedCross });
    const tempConfig = buildConfigFromSettings(merged);
    const tempBase = computeZonesFromSettings(merged);
    const tempPace = applyAdjustment(tempBase, merged.adjustment);
    return generatePlan({ pace: tempPace, settings: merged, config: tempConfig });
  }
  function runTests() {
    const prevSettingsRaw = localStorage.getItem(SETTINGS_KEY);
    const prevPlanRaw = localStorage.getItem(STORAGE_KEY);
    const prevSettings = currentSettings;
    const prevState = state;
    try {
      const p = generatePlan();
      assert("plan length matches config", p.length === CONFIG.weeks);
      const longIdx = Number(currentSettings.longRunDay);
      const w0 = p[0];
      assert("Selected day has long run key", w0.days[longIdx].sessions.some((s) => s.sport === "run" && s.intensity === "key" && s.title.includes("Long Run")));

      // New tests for scaling
      const p20 = generatePlanWithSettings({ planLength: 20 });
      const struct20 = getPlanStructure(20);
      assert("N=20: Taper <= 3", struct20.taperWeeks <= 3);
      assert("N=20: Peak <= 3", struct20.peakWeeks <= 3);
      // Base + Build should be 15 weeks (20 - 2 - 3).
      // Baseline 12. Increase by 3.
      assert("N=20: Base+Build count", struct20.baseWeeks + struct20.buildWeeks === 20 - struct20.taperWeeks - struct20.peakWeeks);
      assert("N=20: Base increases", struct20.baseWeeks > 6);

      // First added week is Base
      // Week 0 is Base. Week 6 is Base (since Base is 7).
      assert("Week 0 is Base", p20[0].phase.startsWith("Base"));
      assert("Week 6 is Base", p20[6].phase.startsWith("Base"));
      assert("Week 7 is Build", p20[7].phase.startsWith("Build"));

      // Long run progression N=20
      // Check intermediate steps.
      const lr0 = p20[0].days[longIdx].sessions.find(isKeyRun).minutes;
      const lr1 = p20[1].days[longIdx].sessions.find(isKeyRun).minutes;
      assert("N=20: Long run ramps up", lr1 >= lr0);
      // Check progression is interpolated (more gradual than +10)
      // 90 -> 100 in week 1
      assert("N=20: Week 1 long run", lr1 === 100);

      const plan12 = generatePlanWithSettings({ planLength: 12 });
      assert("custom plan length", plan12.length === 12);

      const wedPlan = generatePlanWithSettings({ longRunDay: "2" });
      assert("Wednesday long run placement", wedPlan.every((w) => w.days[2].sessions.some((s) => s.title.includes("Long Run"))));

      const crossPlan = generatePlanWithSettings({ crossTraining: { swim: { enabled: false, minutes: 0 }, bike: { enabled: true, minutes: 80 }, strength: { enabled: true, minutes: 45 } } });
      assert("Swim removed when disabled", crossPlan[0].days.every((d) => d.sessions.every((s) => s.sport !== "swim")));
      const bikeSessions = crossPlan[0].days.flatMap((d) => d.sessions.filter((s) => s.sport === "bike"));
      const bikeTotal = bikeSessions.reduce((a, b) => a + b.minutes, 0);
      assert("Bike minutes redistributed", bikeTotal === 80 && bikeSessions.every((s) => s.minutes === bikeSessions[0].minutes));

      const goalZones = computeZonesFromSource("goal", MARATHON_KM, parseTimeInput("3:30:00"), parseTimeInput("3:30:00"), parseTimeInput("1:40:00"));
      assert("Goal MP around 4:55–5:05/km", goalZones.mp[0] >= 292 && goalZones.mp[1] <= 307);
      const adjustedZones = applyAdjustment(goalZones, 30);
      assert("Heat adjustment shifts easy", Math.abs(adjustedZones.easy[0] - goalZones.easy[0] - 30) < 1 && Math.abs(adjustedZones.mp[0] - goalZones.mp[0] - 30) < 1);
      const mpSec = goalZones.mp[0];
      const miSec = convertSecPerKmToUnit(mpSec, "mi");
      const miLabel = secondsToPaceString(mpSec, "mi");
      const expectedMi = `${Math.floor(miSec / 60)}:${String(Math.round(miSec % 60)).padStart(2, "0")}/mi`;
      assert("Unit toggle converts MP", miLabel === expectedMi);
      const beforeGuide = el.paceGuide.textContent;
      refreshPaces({ adjustment: (currentSettings.adjustment || 0) + 5 });
      const afterGuide = el.paceGuide.textContent;
      assert("Pace guide reacts to adjustment", beforeGuide !== afterGuide);
      refreshPaces({ paceSource: "trial", trialDistance: "5", trialTime: "0:22:00" });
      const sourceGuide = el.paceGuide.textContent;
      assert("Pace guide reacts to source change", sourceGuide !== afterGuide);
      refreshPaces({ adjustment: prevSettings.adjustment, paceSource: prevSettings.paceSource, trialDistance: prevSettings.trialDistance, trialTime: prevSettings.trialTime, unit: prevSettings.unit });

      renderPaceGuide(true);
      renderPaceGuide(false);
      const uiState = JSON.parse(localStorage.getItem(UI_STATE_KEY));
      assert("Pace guide collapsed state persisted", uiState && uiState.paceCollapsed === false);
      renderPaceGuide(true);

      const w = generateWeek(0, { pace: PACE, settings: currentSettings });
      const plan = [w];
      const long = w.days[longIdx].sessions.find((s) => s.sport === "run" && s.intensity === "key");
      long.status = "missed";
      const recoveryIndex = (longIdx + 1) % 7;
      assert("Recovery day initially has no key run", !dayHasKeyRun(w.days[recoveryIndex]));
      applyMissedAdaptiveRule(plan, 0, long.id);
      assert("Long run moved after miss", w.days[recoveryIndex].sessions.some((s) => s.id === long.id));

      const statusWeek = { weekIndex: 0, days: [ { dayIndex: 0, sessions: [{ status: "done" }] }, { dayIndex: 1, sessions: [{ status: "planned" }] } ] };
      assert("Week partial when some planned", getWeekStatus(statusWeek, new Date(2024, 0, 2)) === "partial");
      statusWeek.days[1].sessions[0].status = "missed";
      assert("Week missed when any missed", getWeekStatus(statusWeek, new Date(2024, 0, 2)) === "missed");
      statusWeek.days[1].sessions[0].status = "done";
      assert("Week completed when all done", getWeekStatus(statusWeek, new Date(2024, 0, 6)) === "completed");
      const futureWeek = { weekIndex: 1, days: [] };
      assert("Future week flagged", getWeekStatus(futureWeek, new Date()) === "future");

      const prevMode = UI.detailed; setMode(false); const card = renderSessionCard({ id: "t", sport: "run", title: "Test Session", minutes: 30, intensity: "easy", optional: false, details: "Details", status: "planned", moved: false }, 0); assert("Compact renders data-open false", card.getAttribute("data-open") === "false"); assert("Compact aria-expanded false", card.querySelector(".session-head").getAttribute("aria-expanded") === "false"); setMode(prevMode);

      renderPaceGuide();
      assert("Pace guide present", document.getElementById("paceGuide").textContent.includes("Marathon pace (MP):"));

      setMode(false); renderWeek(state.plan, state.activeWeek); const firstSession = el.weekGrid.querySelector(".session"); assert("Compact mode collapsed", firstSession && firstSession.getAttribute("data-open") === "false"); setMode(prevMode); renderWeek(state.plan, state.activeWeek);

      const target = el.weekGrid.querySelector(".session"); if (target) { target.click(); assert("Selection updates action bar", el.selTitle.textContent === target.querySelector(".session-title").textContent); }

      const persistenceSettings = normalizeSettings({ planLength: 10, longRunDay: "3", unit: "mi", adjustment: 8 });
      savePersonalizationSettings(persistenceSettings);
      applySettings(persistenceSettings, { updateUI: false });
      saveState({ plan: generatePlan({ pace: PACE, settings: currentSettings, config: CONFIG }), activeWeek: 0, selected: { weekIndex: 0, sessionId: null } });
      const persisted = normalizeSettings(loadPersonalizationSettings());
      assert("Settings persisted", persisted.planLength === persistenceSettings.planLength && persisted.longRunDay === persistenceSettings.longRunDay && persisted.unit === "mi" && persisted.adjustment === 8);
      const restoredPlan = loadState();
      assert("Plan state persisted", restoredPlan && restoredPlan.plan && restoredPlan.plan.length === CONFIG.weeks);

      const summaryEl = renderWeekSummary(state.plan[0]);
      assert("Summary renders totals", summaryEl.textContent.includes("Totals:"));
      const summaryRows = summaryEl.querySelectorAll(".week-summary-row");
      assert("Summary shows all days", summaryRows.length === 7);

      UI.summaryMobile = true;
      renderWeek(state.plan, state.activeWeek);
      setSummaryMode(false, 2);
      assert("Summary toggle flips to detailed", UI.summaryMobile === false);
      const scrolled = el.weekGrid.querySelector('[data-day-index="2"]');
      assert("Detailed view present after toggle", !!scrolled);

      toast("✅ Tests passed");
    } catch (e) {
      console.error(e);
      alert(String(e));
      toast("❌ Tests failed");
    } finally {
      if (prevSettingsRaw === null) localStorage.removeItem(SETTINGS_KEY); else localStorage.setItem(SETTINGS_KEY, prevSettingsRaw);
      if (prevPlanRaw === null) localStorage.removeItem(STORAGE_KEY); else localStorage.setItem(STORAGE_KEY, prevPlanRaw);
      applySettings(prevSettings);
      state = prevState;
      selected = state.selected;
      bindWeekSelect();
      renderWeek(state.plan, state.activeWeek);
    }
  }
  el.tests.addEventListener("click", () => { try { runTests(); } catch (e) { console.error(e); alert(String(e)); toast("❌ Tests failed"); } });

  bindWeekSelect();
  renderWeek(state.plan, state.activeWeek);
  saveState({ plan: state.plan, activeWeek: state.activeWeek, selected });
})();
</script>
</body>
</html>
